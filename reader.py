# -*- coding: utf-8 -*-
"""
Created on Mon May  8 15:15:30 2023

@author: lott
GS d- s:+ a- C++ t 5 X R tv b+ D+ G e+++ h r++ 
"""

import numpy as np
import zipfile
import pandas as pd


def verify_columns(header:list):
    if not (header[-1].decode("utf-8").strip().split("\t") == 
            list(columns_dtypes.keys())):
        raise ValueError("Columns in header do not match columns in "
                         + "'columns_dtype'")

def find_header(lines:list, prompt:str = "TimeStamp"):
    """
    Finds the line in which the header ends

    Parameters
    ----------
    lines : list
        List of utf-8 encoded strings.
    prompt : str, optional
        Keyword with which the last line of the header starts.
        The default is "TimeStamp".

    Returns
    -------
    int
        line in which the header ends.

    """
    for i, line in  list(enumerate(lines)):
        if line.decode("utf-8").startswith(prompt):
            return i # return row when found the header
    return -1 # return -1 when no header is found

def find_tail(lines:list, prompt:str = "### Acquisition Ended") -> int:
    """
    Finds the line in which the tail starts

    Parameters
    ----------
    lines : list
        List of utf-8 encoded strings.
    prompt : str, optional
        Keyword with which the first line of the tail starts.
        The default is "### Acquisition Ended".

    Returns
    -------
    int
        line in which the tail starts.

    """
    for i, line in  reversed(list(enumerate(lines))):
        if line.decode("utf-8").startswith(prompt):
            return i # return row when found the tail
    return -1 # return -1 when no tail is found

def seperate_header_tail(lines:list) -> [list, list, list]:
    """
    Seperates the header and tail from the data. Returns each as lists.

    Parameters
    ----------
    lines : list
        List of utf-8 encoded strings..

    Returns
    -------
    [list, list, list]
        List of utf-8 encoded header, data and tail.
        
    """
    headerline = find_header(lines)
    tailline = find_tail(lines)
    header = lines[:headerline+1]
    data = lines[headerline+1:tailline]
    tail = lines[tailline:]
    return [header, data, tail]

def get_rundata(file:str) -> pd.DataFrame:
    """
    Generates a pandas Dataframe containing the RunData of an .OnixExp file.
    
    Removes Header and tail.

    Parameters
    ----------
    file : str
        Path to the .OnixExp file.

    Returns
    -------
    data_df : pd.DataFrame
        Pandas dataframe containing the RunData of an .OnixExp file.

    """
    archive = zipfile.ZipFile(file, "r")
    rundata = archive.open("RunData.txt")
    lines = rundata.readlines()
    header, data, tail = seperate_header_tail(lines)
    
    data_list= []
    for line in data:
        vals = line.decode("utf-8").strip().split("\t")
        
        temp_list = []
        
        for ii in range(0, len(vals)): # correct the datatypes
            # get desired type from dict list(columns_dtypes.values())[ii]
            # then apply type to value (vals[ii])
            temp_list.append(list(columns_dtypes.values())[ii](vals[ii]))
        data_list.append(temp_list)
    
    data_df = pd.DataFrame(data_list, columns=columns_dtypes.keys())
    return data_df

def get_wells(df):
    """
    returns a dataframe that only contains the wells
    """
    return df.loc[:,["V1","V2","V3","V4","V5","V6","V7","V8"]]

def insert_pressure(df):
    """
    Returns a new DataFrame, where "X" is replaced with the pressure in a well
    """
    new_df = df.copy()
    for well in ["V1","V2","V3","V4","V5","V6","V7","V8"]:
        new_df[well] = np.where(new_df[well] == "X", new_df["X"], 0)
    return new_df

def insert_wellvalue(well_series, x_value, non_x_value = 0):
    """
    Replaces the X markings in a well with given value, non-X with non_x_value
    """
    return np.where(well_series == "X", x_value, non_x_value)

def insert_multiple_wellvalues(df:pd.DataFrame, x_values:list, 
                           non_x_values:list = [0,0,0,0,0,0,0,0])-> pd.DataFrame: 
    """
    Replaces the X marking that a well was active with a value.
    
    For each well, the respective value in x_values is used to replace the X.
    Every non-X entry is replaced by the value from non_x_values.
    Outputs a copy of the DataFrame where Xs are replaced.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame generated by rundata_from_.
    x_values : list
        8 item long list that holds a value for each well to replace the X.
    non_x_values : list, optional
        8 item long list that holds a value for each well to replace the non-X.
        The default is [0,0,0,0,0,0,0,0].

    Raises
    ------
    ValueError
        Raised when x_values or non_x_values are not both containing 8 items.

    Returns
    -------
    new_df : pd.DataFrame
        DESCRIPTION.

    """

    if not len(x_values) == len(non_x_values):
        raise ValueError("Amount of values for X and non-X TimeStamps"
                         + " do not match.")
    if not len(x_values) == 8:
        raise ValueError("Amount of values do not match number of wells")
    new_df = df.copy()
    for i in range(0,8):
        new_df[f"V{i+1}"] = insert_wellvalue(new_df[f"V{i+1}"], x_values[i],
                                       non_x_values[i])
    return new_df

def plot_all_wells(df):
    """
    A quick overview plot to see whether the pattern looks good.
    """
    import matplotlib.pyplot as plt
    plt.figure()
    for well in ["V1","V2","V3","V4","V5","V6","V7","V8"]:
        plt.plot(df["TimeStamp"], df[well], label = well)
    plt.legend()
    plt.xlabel("Time / s")
    plt.ylabel("pressure / kPa")
    plt.show()

columns_dtypes = {
    "TimeStamp" : int, # in seconds
    "Step" : int, # step of the experiment
    "Repetition" : int, # count of the repetitions
    "V1" : str, # well 1
    "V2" : str, # well 2
    "V3" : str, # well 3
    "V4" : str, # well 4
    "V5" : str, # well 5
    "V6" : str, # well 6
    "V7" : str, # well 7
    "V8" : str, # well 8
    "X" : float, # pressure
    "Y" : float,
    "Temperature" : float, # Temperature applied to manifold
    "Gas" : str, # which gas is supplied
    "Flags0" : str,
    "Flags1" : str,
    "Flags2" : str,
    "Discrete_Input" : int,
    "StatusRegister" : int,
    "RunState" : int
    }
    
    
if __name__ == "__main__":
    
    file = "test/example_experiment.OnixExp"
    data_df = get_rundata(file)
    plot_all_wells(insert_pressure(data_df))